<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>National Institute of Geoscience | Advanced Data Portal</title>
    <style>
        :root { --paper: #ffffff; --ui-bg: #fdfdfd; --accent: #2ecc71; --danger: #e74c3c; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #ddd; font-family: 'Times New Roman', serif; overflow-x: hidden; }
        
        /* 論文カモフラージュ */
        #doc-layer { position: absolute; inset: 0; z-index: 3000; background: #999; overflow-y: auto; display: flex; flex-direction: column; align-items: center; padding: 40px; }
        .manuscript { background: var(--paper); width: 850px; min-height: 1500px; padding: 100px; box-shadow: 0 0 40px rgba(0,0,0,0.5); line-height: 1.6; text-align: justify; }
        .journal-meta { border-bottom: 2px solid #000; display: flex; justify-content: space-between; font-weight: bold; font-size: 13px; margin-bottom: 30px; }
        .title { font-size: 30px; font-weight: bold; text-align: center; margin-bottom: 30px; }
        .auth-portal { border: 2px solid #1a3c34; padding: 40px; background: #f9f9f9; text-align: center; margin-top: 50px; }
        input { padding: 15px; width: 320px; font-size: 18px; border: 1px solid #ccc; font-family: monospace; outline: none; transition: 0.3s; }
        input:focus { border-color: var(--accent); }

        /* 解析表示 */
        #engine-layer { display: none; position: fixed; inset: 0; background: #eef2f1; z-index: 4000; flex-direction: column; align-items: center; justify-content: center; }
        #hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; gap: 50px; color: #333; font-family: sans-serif; font-weight: 900; font-size: 24px; z-index: 5000; background: rgba(255,255,255,0.8); padding: 10px; border-bottom: 3px solid var(--accent); }
        canvas { background: #aad751; border: 8px solid #333; border-radius: 4px; }
        .modal { position: absolute; inset: 0; background: rgba(255,255,255,0.98); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 6000; }
        .btn { background: #2c3e50; color: #fff; border: none; padding: 18px 60px; margin: 10px; cursor: pointer; font-size: 22px; width: 450px; font-weight: 700; transition: 0.3s; }
        .btn:hover { background: var(--accent); transform: scale(1.02); }
    </style>
</head>
<body>

<div id="doc-layer">
    <article class="manuscript">
        <div class="journal-meta"><span>Earth Science Archive</span><span>Ref: GEO-2026-X8TR</span></div>
        <div class="title">Numerical Simulation of Magmatic Viscosity in High-Stress Lithospheric Zones</div>
        <p> Modeling these stochastic behaviors requires a recursive fluid dynamics approach... </p>
        <div class="auth-portal">
            <h3>[ AUTHORIZATION REQUIRED ]</h3>
            <input type="text" id="access_node" placeholder="Verification Code..." onfocus="isInput=true" onblur="isInput=false" onkeydown="if(event.key==='Enter') execute_auth()">
            <p style="font-size: 11px; color: #999; margin-top: 15px;">認証ID: <b>snake.run</b></p>
        </div>
    </article>
</div>

<div id="engine-layer">
    <div id="hud">VALUE: <span id="cur_v" style="color:var(--accent)">0</span> | OPTIMAL: <span id="opt_v">0</span></div>
    <div id="mode-ui" class="modal">
        <h1 style="font-size:40px; margin-bottom:40px;">SELECT ANALYSIS MODEL</h1>
        <button class="btn" onclick="set_type('classic')">TYPE A: DISCRETE LATTICE (SQUARE)</button>
        <button class="btn" onclick="set_type('slither')">TYPE B: CONTINUOUS FLOW (OPEN)</button>
    </div>
    <div id="level-ui" class="modal" style="display:none">
        <h1 style="font-size:40px; margin-bottom:40px;">INTENSITY LEVEL</h1>
        <button class="btn" onclick="run_sim(1)">Level 1: Trace</button>
        <button class="btn" onclick="run_sim(2)">Level 2: Active</button>
        <button class="btn" onclick="run_sim(3)">Level 3: Orogenic</button>
        <button class="btn" onclick="run_sim(4)" style="background:var(--danger)">Level 4: Catastrophic</button>
    </div>
    <canvas id="c"></canvas>
</div>

<script>
const cv = document.getElementById('c'), ctx = cv.getContext('2d');
let core, agents = [], nodes = [], target_node = null, loop, sim_type = '', sim_lvl = 1;
let vecDir = {x:1, y:0}, lastVec = {x:1, y:0}, isInput = false, fCount = 0;
let viewport = {x:0, y:0, zoom:1};
const UNIT = 20, SQUARE_SIZE = 500, FIELD_MAP = 10000;

function execute_auth() {
    if (document.getElementById('access_node').value === 'snake.run') {
        document.getElementById('doc-layer').style.display = 'none';
        document.getElementById('engine-layer').style.display = 'flex';
        document.getElementById('opt_v').innerText = localStorage.getItem('geo_v_opt') || 0;
        resize();
    }
}
function resize() {
    cv.width = (sim_type === 'classic') ? SQUARE_SIZE : window.innerWidth;
    cv.height = (sim_type === 'classic') ? SQUARE_SIZE : window.innerHeight;
}
function set_type(t) { sim_type = t; document.getElementById('mode-ui').style.display='none'; document.getElementById('level-ui').style.display='flex'; resize(); }

window.addEventListener('keydown', e => {
    if(isInput) return;
    const k = e.key.toLowerCase();
    if(['w','arrowup'].includes(k)) vecDir = {x:0, y:-1};
    if(['s','arrowdown'].includes(k)) vecDir = {x:0, y:1};
    if(['a','arrowleft'].includes(k)) vecDir = {x:-1, y:0};
    if(['d','arrowright'].includes(k)) vecDir = {x:1, y:0};
    if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();
});

class ParticleNode {
    constructor(x, y, color, isCore = false) {
        this.x = x; this.y = y; this.color = color; this.isCore = isCore;
        this.pts = Array(sim_type==='classic'?3:15).fill({x, y});
        this.angle = isCore ? 0 : Math.random()*Math.PI*2;
        this.val = 0; this.active = true; this.spawnF = fCount;
    }
    update() {
        if(!this.active) return;
        if(sim_type === 'classic') {
            if(fCount % Math.max(1, 8 - sim_lvl*1.5) !== 0) return;
            if(vecDir.x!==-lastVec.x || vecDir.y!==-lastVec.y) lastVec = {...vecDir};
            this.x += lastVec.x * UNIT; this.y += lastVec.y * UNIT;
            if(this.x<0 || this.x>=SQUARE_SIZE || this.y<0 || this.y>=SQUARE_SIZE) this.terminate();
            for(let i=1; i<this.pts.length; i++) if(this.x===this.pts[i].x && this.y===this.pts[i].y) this.terminate();
            this.pts.unshift({x:this.x, y:this.y});
            if(this.pts.length > 3 + Math.floor(this.val/5)) this.pts.pop();
        } else {
            let speed = (8 + sim_lvl * 3.5); 
            if(this.isCore) {
                let target = Math.atan2(vecDir.y, vecDir.x);
                let d = target - this.angle;
                while(d < -Math.PI) d += Math.PI*2; while(d > Math.PI) d -= Math.PI*2;
                this.angle += d * 0.25;
            } else {
                let distToCore = Math.hypot(this.x - core.x, this.y - core.y);
                if(distToCore < 600 && sim_lvl > 2) this.angle += (Math.atan2(core.y-this.y, core.x-this.x) - this.angle) * 0.15;
                else if(Math.random()>0.97) this.angle += (Math.random()-0.5);
            }
            this.x += Math.cos(this.angle) * speed; this.y += Math.sin(this.angle) * speed;
            if(this.x<0 || this.x>FIELD_MAP || this.y<0 || this.y>FIELD_MAP) this.terminate();
            this.pts.unshift({x:this.x, y:this.y});
            if(this.pts.length > 15 + Math.floor(this.val/4)) this.pts.pop();
        }
    }
    terminate() {
        if (fCount - this.spawnF < 60) return;
        this.active = false;
        if(sim_type === 'slither') {
            this.pts.forEach((p, i) => { if(i%2===0) nodes.push({x:p.x, y:p.y, c:'#fff', v:40, drop:true}); });
            if(!this.isCore) { agents = agents.filter(a => a !== this); spawnAgent(); }
        }
        if(this.isCore) {
            localStorage.setItem('geo_v_opt', Math.max(localStorage.getItem('geo_v_opt')||0, Math.floor(this.val)));
            setTimeout(() => { cancelAnimationFrame(loop); document.getElementById('level-ui').style.display='none'; document.getElementById('mode-ui').style.display='flex'; }, 1000);
        }
    }
}

function run_sim(lvl) {
    sim_lvl = lvl; fCount = 0; document.getElementById('level-ui').style.display = 'none';
    let sPos = (sim_type === 'classic') ? 240 : FIELD_MAP/2;
    core = new ParticleNode(sPos, sPos, '#3498db', true);
    agents = []; nodes = []; target_node = null; vecDir = {x:1, y:0}; lastVec = {x:1, y:0};
    if(sim_type === 'slither') {
        for(let i=0; i<lvl*18; i++) spawnAgent();
        for(let i=0; i<1500; i++) spawnNode();
    } else spawnTarget();
    animate_frame();
}
function spawnAgent() { agents.push(new ParticleNode(Math.random()*FIELD_MAP, Math.random()*FIELD_MAP, '#e74c3c')); }
function spawnNode() { nodes.push({x:Math.random()*FIELD_MAP, y:Math.random()*FIELD_MAP, c:`hsl(${Math.random()*360},70%,60%)`, v:10}); }
function spawnTarget() { target_node = { x: Math.floor(Math.random()*(SQUARE_SIZE/UNIT))*UNIT, y: Math.floor(Math.random()*(SQUARE_SIZE/UNIT))*UNIT }; }

function animate_frame() {
    fCount++;
    if(sim_type === 'slither') {
        let tz = Math.max(0.08, 1.2 - (core.val/5000));
        viewport.zoom += (tz - viewport.zoom) * 0.05;
        viewport.x = core.x - (cv.width/2)/viewport.zoom; viewport.y = core.y - (cv.height/2)/viewport.zoom;
        ctx.fillStyle = '#f8faf9';
    } else { viewport={x:0,y:0,zoom:1}; ctx.fillStyle='#aad751'; }
    
    ctx.fillRect(0, 0, cv.width, cv.height);
    ctx.save(); ctx.scale(viewport.zoom, viewport.zoom); ctx.translate(-viewport.x, -viewport.y);

    if(sim_type === 'classic' && target_node) {
        ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.arc(target_node.x+10, target_node.y+10, 8, 0, 7); ctx.fill();
        if(core.x === target_node.x && core.y === target_node.y) { core.val += 20; spawnTarget(); }
    } else {
        nodes.forEach((n, i) => {
            ctx.fillStyle = n.c; ctx.beginPath(); ctx.arc(n.x, n.y, n.drop?15:8, 0, 7); ctx.fill();
            [core, ...agents].forEach(s => {
                if(s.active && Math.hypot(s.x-n.x, s.y-n.y) < 40) { s.val += n.v; nodes.splice(i,1); }
            });
        });
        if(nodes.length < 1500) spawnNode();
    }

    [core, ...agents].forEach(s => {
        s.update(); if(!s.active) return;
        [core, ...agents].forEach(other => {
            if(!other.active || (s===other && fCount-s.spawnF < 100)) return;
            other.pts.forEach((p, idx) => {
                if(s===other && idx < 12) return;
                if(Math.hypot(s.x-p.x, s.y-p.y) < (sim_type==='classic'?16:32)) s.terminate();
            });
        });
        ctx.fillStyle = s.color;
        s.pts.forEach((p, i) => {
            ctx.beginPath(); ctx.arc(p.x, p.y, sim_type==='classic'?9:32*(1-i/s.pts.length*0.7), 0, 7); ctx.fill();
        });
    });
    ctx.restore();
    document.getElementById('cur_v').innerText = Math.floor(core.val);
    if(core.active) loop = requestAnimationFrame(animate_frame);
    else { ctx.fillStyle="#c0392b"; ctx.font="bold 50px Arial"; ctx.fillText("ANALYSIS FAILED", cv.width/2-200, cv.height/2); }
}
</script>
</body>
</html>
